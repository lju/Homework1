<html>
<canvas id="myCanvas" width="400" height="400"
        style="border:1px solid #000000;">
</canvas>
<script>

var canvas = document.getElementById("myCanvas");
var ctx = canvas.getContext("2d");

/*********************************/
/* constants */
/*********************************/

var MAX_HEALTH = 100;
var SHIP_IMAGE = "ship.png";
var ASTEROID_IMAGE = "asteroid.png";
var PERIOD = 50; // how many ms to wait between calls to mainLoop.
var ACCELERATION = 0.1;
var TURN_SPEED = 0.05; // radians/period when holding left or right
// TODO: have torque instead. Need angular momentum. Shouldn't be too hard.

var LEFT = 37;
var UP = 38;
var RIGHT = 39;
var DOWN = 40;

function updateLocation() {
    this.x += this.vx;
    this.y += this.vy;
};

/*********************************/
/* objects */
/*********************************/

function Ship(x, y, vx, vy, radius, direction) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.radius = radius; // ship is a circle
    this.direction = direction; // direction in radians
    this.health = MAX_HEALTH;
    this.img = new Image();
    this.img.src = "arrow.jpg";

    this.update = function() {
        /////////// direction ////////////
        if (keyPressed(LEFT)) {
            this.direction -= TURN_SPEED;
        }
        if (keyPressed(RIGHT)) {
            this.direction += TURN_SPEED;
        }
        ////////// acceleration //////////
        var ax, ay, scale = 0;
        if (keyPressed(UP)) {
            scale += ACCELERATION;
        }
        if (keyPressed(DOWN)) {
            scale -= ACCELERATION;
        }
        var vec = unitVector(this.direction);
        ax = vec[0];
        ay = vec[1];
        ax *= scale;
        ay *= scale;
        this.vx += ax;
        this.vy += ay;

        this.x = modulo(this.x + this.vx, 400);
        this.y = modulo(this.y + this.vy, 400);
    };

    this.draw = function() {
        // TODO: x, y are center, not top-left
        ctx.save();
        ctx.translate(Math.floor(ship.x), Math.floor(ship.y));
        ctx.rotate(ship.direction);
        ctx.drawImage(this.img, 0, 0, 20, 20);
        ctx.restore();
    };

};

function Asteroid(x, y, vx, vy, radius) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.radius = radius;
    this.update = function() {
        this.x += this.vx;
        this.y += this.vy;
    };
};

function Bullet(x, y, vx, vy, radius) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.radius = radius;
    this.update = function() {
        this.x += this.vx;
        this.y += this.vy;
    };
};

/*********************************/
/* setup */
/*********************************/

var ship = new Ship(100, 100, 1, 1, 5, 0);

/* The function that starts it all. Do some basic startup garbage, call
 * mainLoop, and you're done. */
function run() {
    canvas.addEventListener('keydown', onKeyDown, false);
    canvas.addEventListener('keyup', onKeyUp, false);
    canvas.setAttribute('tabindex','0');
    canvas.focus();
    setInterval(mainLoop, PERIOD);
}

/* This function is called to update everything: move the ship, kill things,
 * draw everything. */
function mainLoop() {
    ship.update();
    drawAll();
};

/*********************************/
/* keys */
/*********************************/

var keys = [];

/* This is the only function you'll use to check if a key is currently
 * pressed. */
function keyPressed(keyCode) {
    return keys[keyCode] === true;
}

function onKeyDown(event) {
    keys[event.keyCode] = true;
}

function onKeyUp(event) {
    delete keys[event.keyCode];
}


/*********************************/
/* drawing */
/*********************************/

/* This is the place where everything is drawn from. Every drawFoo() function
 * should be called here and only here! */
function drawAll() {
    ctx.clearRect(0, 0, 400, 400);
    ship.draw();
};

run();


/*********************************/
/* helper functions */
/*********************************/

/* returns a new theta that is the same angle, but
 * 0 <= modulo(theta, x) < x
 *
 * modulo(120, 100) === 20
 * modulo(-120, 100) === 80
 * modulo(4.0, 1.3) === 0.1
 *
 * This is basically the same as the Python % operator.
 */
function modulo(theta, x) {
    if (theta >= 0) {
        return theta % x;
    } else {
        // negative mod doesn't do what we want, so we need to make it positive
        // by adding a multiple of of 2*x.
        var multiple = Math.abs(Math.floor(theta / x));
        return (theta + (multiple*x)) % x;
    }
};

/* Given a theta in radians, returns an [x, y] unit vector.
 *
 * unitVector(0.0) === [1.0, 0.0]
 * unitVector(Math.PI/2) === [0.0, 1.0]
 * unitVector(Math.PI/4) === [0.707, 0.707] // 1/sqrt(2)
 *
 */
function unitVector(theta) {
    theta = modulo(theta, Math.PI*2);
    // quadrant 0, 1, 2, or 3, in counter-clockwise order
    var quadrant = Math.floor(theta / (Math.PI/2));
    var x, y;
    //////////////// scary trig section //////////////////
    switch (quadrant) {
    case 0:
        x = Math.cos(theta);
        y = Math.sin(theta);
        break;
    case 1:
        theta = Math.PI - theta;
        x = -Math.cos(theta);
        y = Math.sin(theta);
        break;
    case 2:
        theta = theta - Math.PI;
        x = -Math.cos(theta);
        y = -Math.sin(theta);
        break;
    case 3:
        theta = Math.PI*2 - theta;
        x = Math.cos(theta);
        y = -Math.sin(theta);
        break;
    }
    return [x, y];
};


</script>
</html>
